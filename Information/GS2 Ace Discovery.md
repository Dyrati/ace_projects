ACE is now a reality in GS2!!

How it was discovered:

Anywhere in the game, in towns/dungeons, you can use cyclone to gain height so long as there is a cyclone event (`0xEB` tile) at your position in the 3rd layer (`64` tiles below you, or `0x8000` bytes).  In Air's Rock, floating platforms update the third layer when stepped on, to change their graphics.  The address updated is based on your position, eg. if you move right one tile, the updated address moves right one tile.  If you move down, the updated address moves down with you.

Interestingly, if you increase your z coordinate, the updated address moves up as if you had moved up one tile in the y direction (up in the y direction is towards negative y).  However, the floating platform only cares about your x and y coordinate to determine if you're standing on it or not.  So by changing your z coordinate, you can move the updated address up and down, practically arbitrarily.

The x-coordinate of the updated address is a bit more restricted, but there are still several options.  Using leftover data from your last enemy encounter, you can get floating platform tiles at several different x coordinates.  Combining that with using cyclone out of bounds gets you nearly arbitrary memory writes (to EWRAM region, aka `02000000-02040000`).

The floating platforms only write to the last 11 bits of 32-bit aligned memory addresses.  The remaining 21 bits are unchanged, unlike in Tret where the remaining bits were set to 0.

**Plexa** has [a great video](https://www.youtube.com/watch?v=nqBgfYE5RrI&t=32s&pp=ygUgdGwgcGxleGEgYXJiaXRyYXJ5IG1lbW9yeSB3cml0ZXM%3D) explaining what I've mentioned so far, and **Teawater** figured all that out.  Awesome stuff.

When loading a map, various map functions are copied from ROM into EWRAM, from `02008000` to `0200E000`.  That region is within our capabilities to edit.  Some of these functions are only called when the map is loaded, but others can be triggered by doing things, and some are called every frame.  If we can just get the CPU to branch to a region of memory that we have sufficient control over, we have ACE.  Things like names, inventories, stats, and coins are prime targets.  However, all of that easy stuff exists in a very narrow region of memory: `02000000-02001000`

Assuming the game isn't coded nonsensically, all pointers to EWRAM will point to the `02008000-0200E000` region (the region that's supposed to be executed).  Since you can only edit the last 11 bits of a pointer, you can only move that region so much: `+/- 0x800` bytes, which doesn't get us anywhere near memory that we have control over.  So our only hope is either to edit that code region directly, or somehow modify the code region or pointer region boundaries like for GS1.

In the code region, there are various instructions that modify the stack pointer.  Overwriting any of those causes the CPU to branch to an incorrect address at the end of the function, so it seems quite promising.  However once again, we have a fairly restricted range of influence.  We can only delete stack pointer modifying instructions, not add new ones in (we can only pick from a handful of 11-bit values with the floating platforms).  Furthermore, deleting more than one sp-related instruction within a single function that's called automatically is not feasible, because your first edit will almost certainly cause a crash.  So, I looked at all the single-edit options, and there was not a single one capable of causing the CPU to branch to a prime-target memory region.  Normal branch instructions are no better.  Once again our range of influence is only `+/- 0x800` bytes, which doesn't get us anywhere useful.  Every option crashes immediately.

But there's one instruction that's actually useful.  Bl instructions are unique in that they are the only 32-bit thumb instructions.  Their branch range is `+/- 0x400000`, which is huge.  Not enough to branch to a different memory domain, but certainly enough to open up EWRAM.  I generated a list of all possible branch locations from all possible floating platform edits of each bl instruction in the `02008000-0200E000` region of memory.  But once again, **_none_** of them branched to the prime-target region.

The issue came back to the 11-bit writes.  Bl instructions are split up into two halves.  The lower half (bits 0-15) controls the upper 11 bits (including the sign bit) of the jump distance.  The upper half controls the lower 11 bits of the jump distance.  We cannot edit both at the same time.  We can only edit one or the other, depending on how the bl instruction is aligned.  Editing the upper half alone is once again not useful for the same reasons as the other branch options: the branch range is too small: 0x1000 bytes, positive only.  The lower half however, is much more interesting, but we can only move in intervals of 0x1000 bytes.  Furthermore, we can't make it go very far in the negative direction, because our platform writes are restricted to `0x19C, 0x1A8, 0x1A9, 0x1AA, 0xC5, 0xC7, 0xC8, 0xE1, and 0xE3`, all of which cause a positive jump, meaning we cannot cause it to branch below the code region, at least not directly.

But there is a way.  By branching far enough forwards, we actually go backwards, because the EWRAM region repeats itself every 0x40000 bytes.  But while in theory that could work, **_none_** of the valid platform write values can branch to `02000000-02001000` memory mirrors (I checked).  But there are other regions.

It is possible to branch to the address in memory that stores your x and y coordinates, but that's not a great solution because your x and y coords are restricted due to needing to step on a floating platform, and also bad subpixels could break things.  There really aren't any memory addresses (that I know of) out of the regions that we can branch to that we have sufficient control over... without heap corruption.

Thanks to **DriftingPancake**, various heap corruption methods were discovered, resulting in garbage data filling up the "free space" in EWRAM and IWRAM.  One of those methods involves opening the password menu and closing it.  Each time you do that, `0x1DC` bytes relating to that menu are never deallocated.

When you enter a map, the RAM gets cleared, up to a point.  For Air's Rock, that point is `02038F00`.  By pushing the free space pointer down far enough with the password menu, you can get the corruption to survive just past the deletion point.  Within each group of `0x1DC` bytes of password corruption exists a small section containing the last text that you input in the password menu before closing it.

So at this point, we have a very large region of memory `(02038F00-02040000)` that we have control over.  Again, none of the bl instructions reach it, but a small fraction of them get just close enough to skip over the last clump of impassable garbage data before it.  A small fraction of those are accessible from Air's Rock functions that we can trigger, and a small fraction of those (only one left at this point) have consistent floating platforms that can edit them within a reasonable number of cyclones.

Once the CPU reaches the stale password data, it can be instructed to activate debug mode, and execute from the flags.  Thus, we have ACE.
